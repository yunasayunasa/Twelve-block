// --- 定数 ---
const PADDLE_WIDTH_RATIO = 0.2;
const PADDLE_HEIGHT = 20;
const PADDLE_Y_OFFSET = 50;
const BALL_RADIUS = 12;
const BALL_INITIAL_VELOCITY_Y = -350;
const BALL_INITIAL_VELOCITY_X_RANGE = [-150, 150];
const BRICK_ROWS = 5;
const BRICK_COLS = 8;
const BRICK_WIDTH_RATIO = 0.1;
const BRICK_HEIGHT = 20;
const BRICK_SPACING = 4;
const BRICK_OFFSET_TOP = 100;

const GAME_MODE = { NORMAL: 'normal', ALL_STARS: 'all_stars' };
const BRICK_COLORS = [ 0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff ];
const BRICK_MARKED_COLOR = 0x666666;
const DEFAULT_BALL_COLOR = 0x00ff00;

const POWERUP_DROP_RATE = 0.7;
const POWERUP_SIZE = 15;
const POWERUP_SPEED_Y = 100;
const POWERUP_TYPES = {
    KUBIRA: 'kubira', SHATORA: 'shatora', HAILA: 'haila', ANCHIRA: 'anchira', SINDARA: 'sindara',
    BIKARA: 'bikara', INDARA: 'indara', ANILA: 'anila', BAISRAVA: 'baisrava', VAJRA: 'vajra',
    MAKIRA: 'makira', MAKORA: 'makora'
};
const POWERUP_COLORS = {
    [POWERUP_TYPES.KUBIRA]: 0x800080, [POWERUP_TYPES.SHATORA]: 0xffa500, [POWERUP_TYPES.HAILA]: 0xadd8e6,
    [POWERUP_TYPES.ANCHIRA]: 0xffc0cb, [POWERUP_TYPES.SINDARA]: 0xd2b48c, [POWERUP_TYPES.BIKARA]: 0xffffff,
    [POWERUP_TYPES.INDARA]: 0x4682b4, [POWERUP_TYPES.ANILA]: 0xffefd5, [POWERUP_TYPES.BAISRAVA]: 0xffd700,
    [POWERUP_TYPES.VAJRA]: 0xffff00, [POWERUP_TYPES.MAKIRA]: 0x008080, [POWERUP_TYPES.MAKORA]: 0xfa8072,
};
const BIKARA_COLORS = { yin: 0x444444, yang: 0xfffafa };
const POWERUP_DURATION = { [POWERUP_TYPES.KUBIRA]: 10000, [POWERUP_TYPES.SHATORA]: 3000, [POWERUP_TYPES.HAILA]: 10000, [POWERUP_TYPES.MAKIRA]: 10000, [POWERUP_TYPES.MAKORA]: 15000 };
const BIKARA_YANG_COUNT_MAX = 2;
const INDARA_MAX_HOMING_COUNT = 3;
const NORMAL_BALL_SPEED = Math.abs(BALL_INITIAL_VELOCITY_Y);
const BALL_SPEED_MODIFIERS = { [POWERUP_TYPES.SHATORA]: 3.0, [POWERUP_TYPES.HAILA]: 0.3 };
const SINDARA_ATTRACTION_DELAY = 3000;
const SINDARA_ATTRACTION_FORCE = 400;
const SINDARA_MERGE_DURATION = 500;
const SINDARA_ATTRACT_COLOR = 0xa52a2a;
const SINDARA_MERGE_COLOR = 0xff4500;
const VAJRA_GAUGE_MAX = 100;
const VAJRA_GAUGE_INCREMENT = 10;
const VAJRA_DESTROY_COUNT = 5;
const MAKIRA_ATTACK_INTERVAL = 1000;
const MAKIRA_BEAM_SPEED = 400;
const MAKIRA_BEAM_WIDTH = 10;
const MAKIRA_BEAM_HEIGHT = 15;
const MAKIRA_BEAM_COLOR = 0xff0000;
const MAKIRA_FAMILIAR_OFFSET = 40;
const MAKIRA_FAMILIAR_SIZE = 10;
const MAKIRA_FAMILIAR_COLOR = 0x00ced1;
const MAKORA_PADDLE_GAP_RATIO = 0.05;

// --- BootScene ---
class BootScene extends Phaser.Scene { constructor() { super('BootScene'); } preload() { console.log("B:Preload"); } create() { console.log("B:Create"); this.scene.start('TitleScene'); } }

// --- TitleScene ---
class TitleScene extends Phaser.Scene { constructor() { super('TitleScene'); } create() { const w = this.scale.width, h = this.scale.height; this.cameras.main.setBackgroundColor('#222'); this.add.text(w/2,h*0.2,'十二神将ブロック崩し',{fontSize:'40px',fill:'#fff',fontStyle:'bold'}).setOrigin(0.5); this.add.text(w/2,h*0.3,'(仮)',{fontSize:'20px',fill:'#fff'}).setOrigin(0.5); const bs={fontSize:'32px',fill:'#fff',backgroundColor:'#555',padding:{x:20,y:10}}; const bhs={fill:'#ff0'}; const nb=this.add.text(w/2,h*0.5,'通常',bs).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerover',()=>{nb.setStyle(bhs)}).on('pointerout',()=>{nb.setStyle(bs)}).on('pointerdown',()=>{console.log("通常");this.scene.start('GameScene',{mode:GAME_MODE.NORMAL});this.scene.launch('UIScene');}); const asb=this.add.text(w/2,h*0.7,'全員',bs).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerover',()=>{asb.setStyle(bhs)}).on('pointerout',()=>{asb.setStyle(bs)}).on('pointerdown',()=>{console.log("全員");this.scene.start('GameScene',{mode:GAME_MODE.ALL_STARS});this.scene.launch('UIScene');}); } }

// --- GameScene ---
class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); this.paddle=null; this.balls=null; this.bricks=null; this.powerUps=null; this.lives=0; this.gameOverText=null; this.isBallLaunched=false; this.gameWidth=0; this.gameHeight=0; this.currentMode=null; this.currentStage=1; this.score=0; this.ballPaddleCollider=null; this.ballBrickCollider=null; this.ballBrickOverlap=null; this.ballBallCollider=null; this.powerUpTimers={}; this.sindaraAttractionTimer=null; this.sindaraMergeTimer=null; this.isStageClearing=false; this.isGameOver=false; this.isVajraSystemActive=false; this.vajraGauge=0; this.isMakiraActive=false; this.familiars=null; this.makiraBeams=null; this.makiraAttackTimer=null; this.isMakoraActive=false; this.paddle2=null; this.ballPaddle2Collider=null; }
    init(data) { this.currentMode=data.mode||GAME_MODE.NORMAL; this.lives=(this.currentMode===GAME_MODE.ALL_STARS)?1:3; this.isBallLaunched=false; this.currentStage=1; this.score=0; Object.values(this.powerUpTimers).forEach(t=>{if(t)t.remove();}); this.powerUpTimers={}; if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove(); this.sindaraAttractionTimer=null; if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove(); this.sindaraMergeTimer=null; this.isStageClearing=false; this.isGameOver=false; this.isVajraSystemActive=false; this.vajraGauge=0; this.isMakiraActive=false; if(this.makiraAttackTimer)this.makiraAttackTimer.remove(); this.makiraAttackTimer=null; this.isMakoraActive=false; console.log(`GS:Init ${this.currentMode} L:${this.lives}`); }
    preload() {}
    create() { console.log("GS:Create Start"); this.gameWidth=this.scale.width; this.gameHeight=this.scale.height; this.cameras.main.setBackgroundColor('#222'); this.time.delayedCall(50,()=>{if(this.scene.isActive('UIScene')){this.events.emit('updateLives',this.lives);this.events.emit('updateScore',this.score);this.events.emit('updateStage',this.currentStage);}else console.warn("UI not active");}); this.physics.world.setBoundsCollision(true,true,true,false); this.physics.world.on('worldbounds',this.handleWorldBounds,this); const ipw=this.gameWidth*PADDLE_WIDTH_RATIO; this.paddle=this.physics.add.image(this.gameWidth/2,this.gameHeight-PADDLE_Y_OFFSET,null).setDisplaySize(ipw,PADDLE_HEIGHT).setTint(0xffffff).setImmovable(true).setData('originalWidth',ipw); this.balls=this.physics.add.group({bounceX:1,bounceY:1,collideWorldBounds:true}); this.createAndAddBall(this.paddle.x,this.paddle.y-PADDLE_HEIGHT/2-BALL_RADIUS); this.createBricks(); this.gameOverText=this.add.text(this.gameWidth/2,this.gameHeight/2,'G Over\nTap',{fontSize:'48px',fill:'#f00',align:'center'}).setOrigin(0.5).setVisible(false).setDepth(1); this.powerUps=this.physics.add.group(); this.familiars=this.physics.add.group(); this.makiraBeams=this.physics.add.group(); this.makoraBullets=this.physics.add.group(); this.setColliders(); this.physics.add.overlap(this.paddle,this.powerUps,this.collectPowerUp,null,this); this.physics.add.overlap(this.paddle2,this.powerUps,this.collectPowerUp,(p,pu)=>{return this.paddle2&&this.paddle2.active;},this);
        this.input.on('pointermove',(p)=>{ if(!this.isGameOver&&this.lives>0&&this.paddle&&!this.isStageClearing){ const targetX = p.x; if (this.isMakoraActive && this.paddle2?.active) { const gap = this.gameWidth * MAKORA_PADDLE_GAP_RATIO; const paddleWidth = this.paddle.getData('originalWidth') || this.gameWidth * PADDLE_WIDTH_RATIO; const halfWidth = paddleWidth / 2; const minX = halfWidth + gap / 2; const maxX = this.gameWidth - minX; const clampedTargetX = Phaser.Math.Clamp(targetX, minX, maxX); this.paddle.x = clampedTargetX - gap / 2 - halfWidth; this.paddle2.x = clampedTargetX + gap / 2 + halfWidth; if (!this.isBallLaunched) { this.balls.getChildren().forEach(b => { if (b.active) b.x = clampedTargetX; }); } } else { const hw = this.paddle.displayWidth / 2; const ctx = Phaser.Math.Clamp(targetX, hw, this.gameWidth - hw); this.paddle.x = ctx; if (!this.isBallLaunched) { this.balls.getChildren().forEach(b => { if(b.active) b.x = ctx; }); } } } });
        this.input.on('pointerdown',()=>{if(this.isGameOver&&this.gameOverText?.visible){this.returnToTitle();} else if(this.lives>0&&!this.isBallLaunched&&!this.isStageClearing){this.launchBall();}});
        this.events.on('shutdown',this.shutdown,this); console.log("GS:Create End");}
    update() { if(this.isGameOver||this.isStageClearing||this.lives<=0)return; let ac=0; let sa=[]; this.balls.getChildren().forEach(b=>{if(b.active){ac++;if(this.isBallLaunched&&!this.isStageClearing&&b.y>this.gameHeight+b.displayHeight){if(b.getData('isAnilaActive'))this.triggerAnilaBounce(b);else{b.setActive(false).setVisible(false);if(b.body)b.body.enable=false;}}if(b.getData('isSindara')){sa.push(b);if(b.getData('isAttracting'))this.updateSindaraAttraction(b);}if(b.body&&this.isBallLaunched){const min=NORMAL_BALL_SPEED*0.1,max=NORMAL_BALL_SPEED*5,sp=b.body.velocity.length();if(sp<min&&sp>0)b.body.velocity.normalize().scale(min);else if(sp>max)b.body.velocity.normalize().scale(max);}}}); if(sa.length===1&&this.balls.getTotalUsed()>1){const r=sa[0];if(r.getData('isSindara')){this.deactivateSindara([r]);this.updateBallTint(r);}} if(ac===0&&this.isBallLaunched&&!this.isStageClearing&&this.lives>0)this.loseLife(); this.powerUps.children.each(pu=>{if(pu.active&&pu.y>this.gameHeight+POWERUP_SIZE)pu.destroy();}); if(this.balls.countActive(true)===1){const lb=this.balls.getFirstAlive();if(lb&&lb.getData('isAnchira')){this.deactivateAnchira([lb]);this.updateBallTint(lb);}} if(this.isMakiraActive&&this.paddle&&this.familiars){const px=this.paddle.x;const py=this.paddle.y-PADDLE_HEIGHT/2-MAKIRA_FAMILIAR_SIZE;const c=this.familiars.getChildren();if(c.length>=1&&c[0].active)c[0].setPosition(px-MAKIRA_FAMILIAR_OFFSET,py);if(c.length>=2&&c[1].active)c[1].setPosition(px+MAKIRA_FAMILIAR_OFFSET,py);} if(this.makiraBeams){this.makiraBeams.children.each(bm=>{if(bm.active&&bm.y<-MAKIRA_BEAM_HEIGHT)bm.destroy();});} if(this.makoraBullets){ this.makoraBullets.children.each(bu=>{if(bu.active&&bu.y<-MAKORA_BULLET_SIZE*2)bu.destroy();});}}
    setColliders() { if(this.ballPaddleCollider)this.ballPaddleCollider.destroy();if(this.ballBrickCollider)this.ballBrickCollider.destroy();if(this.ballBrickOverlap)this.ballBrickOverlap.destroy();if(this.ballBallCollider)this.ballBallCollider.destroy();if (this.ballPaddle2Collider) this.ballPaddle2Collider.destroy(); this.ballPaddle2Collider = null; if(!this.balls||!this.paddle||!this.bricks){console.error("SetColliders: Missing objects.");return;} this.ballPaddleCollider=this.physics.add.collider(this.paddle,this.balls,this.hitPaddle,null,this); if (this.paddle2 && this.paddle2.active) { this.ballPaddle2Collider = this.physics.add.collider(this.paddle2, this.balls, this.hitPaddle, null, this); console.log("P2 collider set.");} this.ballBrickCollider=this.physics.add.collider(this.bricks,this.balls,this.hitBrick,(br,b)=>{const ib=b.getData('isBikara');const ip=b.getData('isPenetrating');const im=b.getData('isSindara')&&b.getData('isMerging');if(ib||ip||im)return false;return true;},this); this.ballBrickOverlap=this.physics.add.overlap(this.balls,this.bricks,this.handleBallBrickOverlap,(b,br)=>b.getData('isPenetrating')||(b.getData('isSindara')&&(b.getData('isAttracting')||b.getData('isMerging')))||b.getData('isBikara'),this); this.ballBallCollider=this.physics.add.collider(this.balls,this.balls,this.handleBallCollision,(b1,b2)=>b1.getData('isSindara')&&b2.getData('isSindara')&&b1.getData('isAttracting')&&b2.getData('isAttracting'),this);
        // ★★★ マキラ・マコラOverlap設定を有効化 ★★★
        console.log(">>> Enabling Makira/Makora overlaps...");
        if (this.makiraBeams && this.bricks) { this.physics.add.overlap(this.makiraBeams, this.bricks, this.hitBrickWithMakiraBeam, null, this); console.log(">>> Makira beam overlap ENABLED."); }
        if (this.makoraBullets && this.bricks) { this.physics.add.overlap(this.makoraBullets, this.bricks, this.hitBrickWithMakoraBullet, null, this); console.log(">>> Makora bullet overlap ENABLED."); }
        console.log("Colliders set/reset.");
    }
    createAndAddBall(x,y,vx=0,vy=0,data=null){const b=this.balls.create(x,y,null).setDisplaySize(BALL_RADIUS*2,BALL_RADIUS*2).setTint(DEFAULT_BALL_COLOR).setCircle(BALL_RADIUS).setCollideWorldBounds(true).setBounce(1);if(b.body){b.setVelocity(vx,vy);b.body.onWorldBounds=true;}else{console.error("CreateBall fail!");b.destroy();return null;}b.setData({activePowers:data?new Set(data.activePowers):new Set(),lastActivatedPower:data?data.lastActivatedPower:null,isPenetrating:data?data.isPenetrating:false,isFast:data?data.isFast:false,isSlow:data?data.isSlow:false,isAnchira:data?data.isAnchira:false,isSindara:data?data.isSindara:false,sindaraPartner:null,isAttracting:false,isMerging:false,isBikara:data?data.isBikara:false,bikaraState:data?data.bikaraState:null,bikaraYangCount:0,isIndaraActive:data?data.isIndaraActive:false,indaraHomingCount:data?data.indaraHomingCount:0,isAnilaActive:data?data.isAnilaActive:false});if(data){this.updateBallTint(b);if(b.getData('isFast'))this.applySpeedModifier(b,POWERUP_TYPES.SHATORA);else if(b.getData('isSlow'))this.applySpeedModifier(b,POWERUP_TYPES.HAILA);}return b;}
    launchBall(){if(!this.isBallLaunched&&this.balls){const fb=this.balls.getFirstAlive();if(fb){const vx=Phaser.Math.Between(BALL_INITIAL_VELOCITY_X_RANGE[0],BALL_INITIAL_VELOCITY_X_RANGE[1]);fb.setVelocity(vx,BALL_INITIAL_VELOCITY_Y);this.isBallLaunched=true;console.log("Ball launched!");}}}
    createBricks(){if(this.bricks){this.bricks.clear(true,true);this.bricks.destroy();}this.bricks=this.physics.add.staticGroup();const bw=this.gameWidth*BRICK_WIDTH_RATIO;const tw=BRICK_COLS*bw+(BRICK_COLS-1)*BRICK_SPACING;const ox=(this.gameWidth-tw)/2;const rows=this.currentMode===GAME_MODE.ALL_STARS?BRICK_ROWS+2:BRICK_ROWS;for(let i=0;i<rows;i++){for(let j=0;j<BRICK_COLS;j++){const bx=ox+j*(bw+BRICK_SPACING)+bw/2;const by=BRICK_OFFSET_TOP+i*(BRICK_HEIGHT+BRICK_SPACING)+BRICK_HEIGHT/2;const rc=Phaser.Utils.Array.GetRandom(BRICK_COLORS);const br=this.bricks.create(bx,by,null).setDisplaySize(bw,BRICK_HEIGHT).setTint(rc);br.setData({hits:1,originalTint:rc,isMarkedByBikara:false});br.refreshBody();}}console.log(`Bricks created:${this.bricks.getLength()}`);}
    hitPaddle(p,b){if(!p||!b||!b.active||!b.body)return;let diff=b.x-p.x;const md=p.displayWidth/2;let inf=diff/md;inf=Phaser.Math.Clamp(inf,-1,1);const maxVx=NORMAL_BALL_SPEED*0.8;let nVx=maxVx*inf;const minVy=NORMAL_BALL_SPEED*0.5;let cvy=b.body.velocity.y;let nVy=-Math.abs(cvy);if(Math.abs(nVy)<minVy)nVy=-minVy;let sm=1.0;if(b.getData('isFast'))sm=BALL_SPEED_MODIFIERS[POWERUP_TYPES.SHATORA];else if(b.getData('isSlow'))sm=BALL_SPEED_MODIFIERS[POWERUP_TYPES.HAILA];const ts=NORMAL_BALL_SPEED*sm;const nv=new Phaser.Math.Vector2(nVx,nVy).normalize().scale(ts);b.setVelocity(nv.x,nv.y);if(b.getData('isBikara'))this.switchBikaraState(b);if(b.getData('isIndaraActive')){console.log("Indara deactivated.");this.deactivateIndaraForBall(b);this.updateBallTint(b);}}
    hitBrick(br,b){if(!br||!b||!br.active||!b.active||this.isStageClearing)return;br.disableBody(true,true);this.score+=10;this.events.emit('updateScore',this.score);this.increaseVajraGauge();if(Phaser.Math.FloatBetween(0,1)<POWERUP_DROP_RATE)this.dropPowerUp(br.x,br.y);if(!this.isStageClearing&&this.bricks.countActive(true)===0){console.log("Last brick hit!");this.stageClear();}}
    handleBallBrickOverlap(b,br){if(!b||!br||!b.active||!br.active||this.isStageClearing)return;const ik=b.getData('isPenetrating');const isa=b.getData('isSindara')&&b.getData('isAttracting');const ism=b.getData('isSindara')&&b.getData('isMerging');const ibk=b.getData('isBikara');const bks=b.getData('bikaraState');if(ibk){console.log(`>>> Ovr:Bikara S:${bks}`);if(bks==='yin'){console.log(">>> Ovr:Yin");this.markBrickByBikara(br);return;}else if(bks==='yang'){console.log(">>> Ovr:Yang");this.handleBikaraYangDestroy(b,br);return;}else{console.warn(`>>> Ovr:Bikara unexp:${bks}`);return;}}if(ik||isa||ism){br.disableBody(true,true);this.score+=10;this.events.emit('updateScore',this.score);this.increaseVajraGauge();if(Phaser.Math.FloatBetween(0,1)<POWERUP_DROP_RATE)this.dropPowerUp(br.x,br.y);if(!this.isStageClearing&&this.bricks.countActive(true)===0){console.log("Last brick penetrated!");this.stageClear();}return;}}
    handleBikaraYangDestroy(b,hb){console.log(">>> Yang Destroy ENTER");if(!b||!b.active||!b.getData('isBikara')||b.getData('bikaraState')!=='yang'){console.warn(">>> Yang Destroy aborted");return;}console.log(">>> Yang Destroy processing...");let dc=0;const mtd=[];if(hb.active){console.log(">>> Adding hit:",hb.x,hb.y);mtd.push(hb);hb.setData('isMarkedByBikara',false);}console.log(">>> Searching marked...");this.bricks.getChildren().forEach(br=>{if(br.active&&br.getData('isMarkedByBikara')&&!mtd.includes(br)){console.log(">>> Adding marked:",br.x,br.y);mtd.push(br);br.setData('isMarkedByBikara',false);}});console.log(`>>> Total destroy:${mtd.length}`);mtd.forEach(br=>{console.log(">>> Destroying:",br.x,br.y);br.disableBody(true,true);this.score+=10;dc++;this.increaseVajraGauge();if(Phaser.Math.FloatBetween(0,1)<POWERUP_DROP_RATE)this.dropPowerUp(br.x,br.y);});if(dc>0){this.events.emit('updateScore',this.score);console.log(`>>> Bikara destroyed ${dc}.`);}let cyc=b.getData('bikaraYangCount')||0;cyc++;b.setData('bikaraYangCount',cyc);console.log(`>>> Yang count:${cyc}`);if(!this.isStageClearing&&this.bricks.countActive(true)===0){console.log(">>> Bikara cleared stage!");this.stageClear();}else if(cyc>=BIKARA_YANG_COUNT_MAX){console.log(">>> Bikara max count.");this.deactivateBikara([b]);this.updateBallTint(b);}console.log(">>> Yang Destroy END");}
    dropPowerUp(x,y){ console.log(">>> dropPowerUp CALLED"); const at=[POWERUP_TYPES.KUBIRA,POWERUP_TYPES.SHATORA,POWERUP_TYPES.HAILA,POWERUP_TYPES.ANCHIRA,POWERUP_TYPES.SINDARA,POWERUP_TYPES.BIKARA,POWERUP_TYPES.INDARA,POWERUP_TYPES.ANILA,POWERUP_TYPES.BAISRAVA,POWERUP_TYPES.VAJRA,POWERUP_TYPES.MAKIRA,POWERUP_TYPES.MAKORA]; const t=Phaser.Utils.Array.GetRandom(at); const c=POWERUP_COLORS[t]||0xffffff; const pu=this.powerUps.create(x,y,null).setDisplaySize(POWERUP_SIZE,POWERUP_SIZE).setTint(c).setData('type',t); if(pu.body){ console.log(">>> Setting powerup velocity"); pu.setVelocity(0,POWERUP_SPEED_Y);pu.body.setCollideWorldBounds(false);pu.body.setAllowGravity(false); console.log(">>> Powerup velocity set");}else{console.error("Failed PU body!");pu.destroy();} console.log(">>> dropPowerUp END");}
    collectPowerUp(p,pu){if(!pu||!pu.active||this.isStageClearing)return;const t=pu.getData('type');if(!t){console.warn("No type!");pu.destroy();return;}pu.destroy(); console.log(`Col:${t}`); if(t===POWERUP_TYPES.BAISRAVA){this.activateBaisrava();return;}if(t===POWERUP_TYPES.VAJRA){this.activateVajra();return;}if(t===POWERUP_TYPES.MAKIRA){this.activateMakira();return;}if(t===POWERUP_TYPES.MAKORA){this.activateMakora();return;}if(t===POWERUP_TYPES.ANCHIRA||t===POWERUP_TYPES.SINDARA){if(this.balls.countActive(true)>1){console.log("Keep furthest.");this.keepFurthestBall();}}this.activatePower(t);}
    keepFurthestBall(){const ab=this.balls.getMatching('active',true);if(ab.length<=1)return;let fb=null;let md=-1;const pp=new Phaser.Math.Vector2(this.paddle.x,this.paddle.y);ab.forEach(b=>{const d=Phaser.Math.Distance.Squared(pp.x,pp.y,b.x,b.y);if(d>md){md=d;fb=b;}});ab.forEach(b=>{if(b!==fb){console.log("Removing closer.");b.destroy();}});console.log("Kept furthest.");}
    activatePower(type){console.log(`Activating:${type}`);const tb=this.balls.getMatching('active',true);if(tb.length===0)return; if(this.isMakoraActive){console.log(`Makora active, ignoring ${type}`);return;} if(this.isMakiraActive) this.deactivateMakira(); this.deactivateVajra(); if(POWERUP_DURATION[type]){if(this.powerUpTimers[type])this.powerUpTimers[type].remove();} switch(type){case POWERUP_TYPES.KUBIRA:this.activateKubira(tb);break;case POWERUP_TYPES.SHATORA:this.activateShatora(tb);break;case POWERUP_TYPES.HAILA:this.activateHaira(tb);break;case POWERUP_TYPES.ANCHIRA:this.activateAnchira(tb[0]);break;case POWERUP_TYPES.SINDARA:this.activateSindara(tb[0]);break;case POWERUP_TYPES.BIKARA:this.activateBikara(tb);break;case POWERUP_TYPES.INDARA:this.activateIndara(tb);break;case POWERUP_TYPES.ANILA:this.activateAnila(tb);break;default:console.warn(`Unknown type:${type}`);return;} tb.forEach(b=>{if(b.active){b.getData('activePowers').add(type);b.setData('lastActivatedPower',type);this.updateBallTint(b);}}); const d=POWERUP_DURATION[type];if(d){this.powerUpTimers[type]=this.time.delayedCall(d,()=>{console.log(`Expired:${type}`);this.deactivatePowerByType(type);this.powerUpTimers[type]=null;},[],this);}}
    deactivatePowerByType(type){console.log(`Deactivating:${type}`);const tb=this.balls.getMatching('active',true);if(tb.length===0)return; if(type===POWERUP_TYPES.MAKIRA){this.deactivateMakira();return;} if(type===POWERUP_TYPES.MAKORA){this.deactivateMakora();return;} switch(type){case POWERUP_TYPES.KUBIRA:this.deactivateKubira(tb);break;case POWERUP_TYPES.SHATORA:this.deactivateShatora(tb);break;case POWERUP_TYPES.HAILA:this.deactivateHaira(tb);break;default:console.warn(`Cannot deactivate:${type}`);return;} tb.forEach(b=>{if(b.active){b.getData('activePowers').delete(type);this.updateBallTint(b);}});}
    updateBallTint(b){if(!b||!b.active)return;const ap=b.getData('activePowers');let t=DEFAULT_BALL_COLOR;if(ap&&ap.size>0){const lp=b.getData('lastActivatedPower');if(lp&&ap.has(lp)){if(lp===POWERUP_TYPES.BIKARA)t=BIKARA_COLORS[b.getData('bikaraState')]||BIKARA_COLORS.yin;else if(lp===POWERUP_TYPES.SINDARA){if(b.getData('isMerging'))t=SINDARA_MERGE_COLOR;else if(b.getData('isAttracting'))t=SINDARA_ATTRACT_COLOR;else t=POWERUP_COLORS[lp];}else if(POWERUP_COLORS[lp])t=POWERUP_COLORS[lp];}else{const rp=Array.from(ap);if(rp.length>0){const nlp=rp[rp.length-1];if(nlp===POWERUP_TYPES.BIKARA)t=BIKARA_COLORS[b.getData('bikaraState')]||BIKARA_COLORS.yin;else if(nlp===POWERUP_TYPES.SINDARA){if(b.getData('isMerging'))t=SINDARA_MERGE_COLOR;else if(b.getData('isAttracting'))t=SINDARA_ATTRACT_COLOR;else t=POWERUP_COLORS[nlp];}else t=POWERUP_COLORS[nlp]||DEFAULT_BALL_COLOR;b.setData('lastActivatedPower',nlp);}}}b.setTint(t);}
    activateKubira(bs){bs.forEach(b=>b.setData('isPenetrating',true));console.log("Kubira on.");}
    deactivateKubira(bs){bs.forEach(b=>{if(!b.getData('isSindara')||(!b.getData('isAttracting')&&!b.getData('isMerging')))b.setData('isPenetrating',false);});console.log("Kubira off.");}
    applySpeedModifier(b,t){if(!b||!b.active||!b.body)return;const m=BALL_SPEED_MODIFIERS[t];if(!m)return;const cv=b.body.velocity;const d=cv.length()>0?cv.clone().normalize():new Phaser.Math.Vector2(0,-1);const ns=NORMAL_BALL_SPEED*m;b.setVelocity(d.x*ns,d.y*ns);}
    resetBallSpeed(b){if(!b||!b.active||!b.body)return;if(b.getData('isFast'))this.applySpeedModifier(b,POWERUP_TYPES.SHATORA);else if(b.getData('isSlow'))this.applySpeedModifier(b,POWERUP_TYPES.HAILA);else{const cv=b.body.velocity;const d=cv.length()>0?cv.clone().normalize():new Phaser.Math.Vector2(0,-1);b.setVelocity(d.x*NORMAL_BALL_SPEED,d.y*NORMAL_BALL_SPEED);}}
    activateShatora(bs){bs.forEach(b=>{b.setData({isFast:true,isSlow:false});this.applySpeedModifier(b,POWERUP_TYPES.SHATORA);});console.log("Shatora on.");}
    deactivateShatora(bs){bs.forEach(b=>{if(b.getData('isFast')){b.setData('isFast',false);this.resetBallSpeed(b);}});console.log("Shatora off.");}
    activateHaira(bs){bs.forEach(b=>{b.setData({isSlow:true,isFast:false});this.applySpeedModifier(b,POWERUP_TYPES.HAILA);});console.log("Haira on.");}
    deactivateHaira(bs){bs.forEach(b=>{if(b.getData('isSlow')){b.setData('isSlow',false);this.resetBallSpeed(b);}});console.log("Haira off.");}
    activateAnchira(sb){console.log("Anchira on");if(!sb||!sb.active)return;sb.setData('isAnchira',true);const x=sb.x,y=sb.y,n=3;for(let i=0;i<n;i++){const ox=Phaser.Math.Between(-5,5),oy=Phaser.Math.Between(-5,5),vx=Phaser.Math.Between(-150,150),vy=-Math.abs(Phaser.Math.Between(100,NORMAL_BALL_SPEED*0.8));const nb=this.createAndAddBall(x+ox,y+oy,vx,vy,sb.data.getAll());if(!nb)console.error("Split fail.");}console.log(`Spawned ${n}.`);}
    deactivateAnchira(bs){console.log("Anchira off");bs.forEach(b=>{if(b.getData('isAnchira')){b.setData('isAnchira',false);b.getData('activePowers').delete(POWERUP_TYPES.ANCHIRA);}});}
    activateSindara(sb){console.log("Sindara on");if(!sb||!sb.active)return;const x=sb.x,y=sb.y;const sB=this.createAndAddBall(x+Phaser.Math.Between(-5,5),y+Phaser.Math.Between(-5,5),Phaser.Math.Between(-150,150),-Math.abs(Phaser.Math.Between(100,NORMAL_BALL_SPEED*0.8)),sb.data.getAll());if(sB){sb.setData({isSindara:true,sindaraPartner:sB,isAttracting:false,isMerging:false});sB.setData({isSindara:true,sindaraPartner:sb,isAttracting:false,isMerging:false});if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove();this.sindaraAttractionTimer=this.time.delayedCall(SINDARA_ATTRACTION_DELAY,()=>{this.startSindaraAttraction(sb,sB);},[],this);console.log("Sindara activated.");}else{console.error("Sindara split fail.");sb.getData('activePowers').delete(POWERUP_TYPES.SINDARA);}}
    startSindaraAttraction(b1,b2){console.log("Attraction start");this.sindaraAttractionTimer=null;if(!b1||!b2||!b1.active||!b2.active||!b1.getData('isSindara')||!b2.getData('isSindara')){console.warn("Cannot start attraction.");const ab=this.balls.getMatching('isSindara',true);if(ab.length>0){this.deactivateSindara(ab);ab.forEach(b=>this.updateBallTint(b));}return;}b1.setData({isAttracting:true,isPenetrating:true});b2.setData({isAttracting:true,isPenetrating:true});this.updateBallTint(b1);this.updateBallTint(b2);console.log("Attracting.");}
    updateSindaraAttraction(b){const p=b.getData('sindaraPartner');if(p&&p.active&&b.active&&b.getData('isAttracting')&&p.getData('isAttracting')&&!b.getData('isMerging')&&!p.getData('isMerging'))this.physics.moveToObject(b,p,SINDARA_ATTRACTION_FORCE);}
    handleBallCollision(b1,b2){if(b1.active&&b2.active&&b1.getData('sindaraPartner')===b2){console.log("Sindara collided!");this.mergeSindaraBalls(b1,b2);}}
    mergeSindaraBalls(b1,b2){console.log("Merging");const bk=b1,br=b2;const mx=(bk.x+br.x)/2,my=(bk.y+br.y)/2;bk.setPosition(mx,my);br.destroy();bk.setData({isMerging:true,isAttracting:false,isPenetrating:true,sindaraPartner:null});this.updateBallTint(bk);if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove();this.sindaraMergeTimer=this.time.delayedCall(SINDARA_MERGE_DURATION,()=>{this.finishSindaraMerge(bk);},[],this);if(this.sindaraAttractionTimer){this.sindaraAttractionTimer.remove();this.sindaraAttractionTimer=null;}console.log("Merge initiated.");}
    finishSindaraMerge(mb){console.log("Finish merge");this.sindaraMergeTimer=null;if(!mb||!mb.active)return;mb.setData({isMerging:false,isPenetrating:false,isSindara:false});mb.getData('activePowers').delete(POWERUP_TYPES.SINDARA);if(mb.getData('activePowers').has(POWERUP_TYPES.KUBIRA))mb.setData('isPenetrating',true);this.resetBallSpeed(mb);this.updateBallTint(mb);console.log("Merge finished.");}
    deactivateSindara(bs){console.log("Sindara off.");if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove();this.sindaraAttractionTimer=null;if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove();this.sindaraMergeTimer=null;bs.forEach(b=>{if(b.active&&b.getData('isSindara')){b.setData({isSindara:false,sindaraPartner:null,isAttracting:false,isMerging:false});if(!b.getData('activePowers').has(POWERUP_TYPES.KUBIRA))b.setData('isPenetrating',false);b.getData('activePowers').delete(POWERUP_TYPES.SINDARA);}});}
    activateBikara(bs){console.log("Bikara on");bs.forEach(b=>b.setData({isBikara:true,bikaraState:'yin',bikaraYangCount:0}));console.log("Bikara activated.");}
    deactivateBikara(bs){console.log("Bikara off");bs.forEach(b=>{if(b.getData('isBikara')){b.setData({isBikara:false,bikaraState:null,bikaraYangCount:0});b.getData('activePowers').delete(POWERUP_TYPES.BIKARA);}});this.bricks.getChildren().forEach(br=>{if(br.getData('isMarkedByBikara')){br.setData('isMarkedByBikara',false);br.setTint(br.getData('originalTint')||0xffffff);}});console.log("Bikara deactivated.");}
    switchBikaraState(b){if(!b||!b.active||!b.getData('isBikara'))return;const cs=b.getData('bikaraState');const ns=(cs==='yin')?'yang':'yin';b.setData('bikaraState',ns);this.updateBallTint(b);console.log(`Bikara state:${ns}`);}
    markBrickByBikara(br){if(!br||!br.active||br.getData('isMarkedByBikara'))return;br.setData('isMarkedByBikara',true);br.setTint(BRICK_MARKED_COLOR);}
    activateIndara(bs){console.log("Indara on");bs.forEach(b=>b.setData({isIndaraActive:true,indaraHomingCount:INDARA_MAX_HOMING_COUNT}));console.log(`Indara activated.`);}
    deactivateIndaraForBall(b){if(!b||!b.active||!b.getData('isIndaraActive'))return;b.setData({isIndaraActive:false,indaraHomingCount:0});b.getData('activePowers').delete(POWERUP_TYPES.INDARA);console.log("Indara off.");}
    handleWorldBounds(body,up,down,left,right){const b=body.gameObject;if(!b||!(b instanceof Phaser.Physics.Arcade.Image)||!this.balls.contains(b)||!b.active)return;if(b.getData('isIndaraActive')&&b.getData('indaraHomingCount')>0&&(up||left||right)){const chc=b.getData('indaraHomingCount');console.log(`Indara hit. C:${chc}`);const ab=this.bricks.getMatching('active',true);if(ab.length>0){let cb=null;let md=Infinity;const bc=b.body.center;ab.forEach(br=>{const d=Phaser.Math.Distance.Squared(bc.x,bc.y,br.body.center.x,br.body.center.y);if(d<md){md=d;cb=br;}});if(cb){console.log("Indara homing.");const cs=b.body.velocity.length();const a=Phaser.Math.Angle.BetweenPoints(bc,cb.body.center);this.physics.velocityFromAngle(a,cs,b.body.velocity);const nhc=chc-1;b.setData('indaraHomingCount',nhc);console.log(`Indara remain:${nhc}`);if(nhc<=0){console.log("Indara deactivated.");this.deactivateIndaraForBall(b);this.updateBallTint(b);}}}else{console.log("Indara no bricks.");}}}
    activateAnila(bs){console.log("Anila on");bs.forEach(b=>{if(!b.getData('isAnilaActive')){b.setData('isAnilaActive',true);console.log("Anila activated.");}});}
    deactivateAnilaForBall(b){if(!b||!b.active||!b.getData('isAnilaActive'))return;b.setData('isAnilaActive',false);b.getData('activePowers').delete(POWERUP_TYPES.ANILA);console.log("Anila off.");}
    triggerAnilaBounce(b){if(!b||!b.active||!b.getData('isAnilaActive'))return;console.log("Anila bounce!");const cvy=b.body.velocity.y;const bvy=-Math.abs(cvy>-10?BALL_INITIAL_VELOCITY_Y*0.7:cvy);b.setVelocityY(bvy);b.y=this.gameHeight-PADDLE_Y_OFFSET-PADDLE_HEIGHT;this.deactivateAnilaForBall(b);this.updateBallTint(b);}
    activateBaisrava(){console.log("Baisrava START");if(this.isStageClearing||this.isGameOver)return;const ab=this.bricks.getMatching('active',true);let dc=0;console.log("Active:",ab.length);ab.forEach(br=>{br.disableBody(true,true);this.score+=10;dc++;});if(dc>0){console.log(`Destroyed ${dc}. Score:${this.score}`);this.events.emit('updateScore',this.score);}else{console.log("No bricks.");}console.log("Baisrava END.");this.stageClear();}
    activateVajra(){if(!this.isVajraSystemActive){this.isVajraSystemActive=true;this.vajraGauge=0;console.log("Vajra On!");this.events.emit('activateVajraUI',this.vajraGauge,VAJRA_GAUGE_MAX);}else{console.log("Vajra already on.");}}
    increaseVajraGauge(){if(this.isVajraSystemActive&&!this.isStageClearing&&!this.isGameOver){this.vajraGauge+=VAJRA_GAUGE_INCREMENT;this.vajraGauge=Math.min(this.vajraGauge,VAJRA_GAUGE_MAX);console.log(`Vajra:${this.vajraGauge}/${VAJRA_GAUGE_MAX}`);this.events.emit('updateVajraGauge',this.vajraGauge);if(this.vajraGauge>=VAJRA_GAUGE_MAX){console.log("Vajra MAX!");this.triggerVajraDestroy();this.vajraGauge=0;this.events.emit('updateVajraGauge',this.vajraGauge);this.deactivateVajra();}}}
    triggerVajraDestroy(){if(this.isStageClearing||this.isGameOver)return;const ab=this.bricks.getMatching('active',true);if(ab.length===0){console.log("Vajra:No bricks.");return;}const cd=Math.min(ab.length,VAJRA_DESTROY_COUNT);console.log(`Vajra destroy ${cd}`);const sb=Phaser.Utils.Array.Shuffle(ab);let dc=0;for(let i=0;i<cd;i++){const br=sb[i];if(br&&br.active){console.log("Vajra destroying:",br.x,br.y);br.disableBody(true,true);this.score+=10;dc++;}}if(dc>0){console.log(`Vajra destroyed ${dc}.`);this.events.emit('updateScore',this.score);}if(!this.isStageClearing&&this.bricks.countActive(true)===0){console.log("Vajra cleared stage!");this.stageClear();}}
    deactivateVajra() { if (this.isVajraSystemActive) { console.log(">>> Deactivating Vajra System."); this.isVajraSystemActive = false; this.vajraGauge = 0; this.events.emit('deactivateVajraUI'); } }
    activateMakira() { console.log(">>> Activating Makira!"); if (!this.isMakiraActive) { this.isMakiraActive = true; if (this.familiars) this.familiars.clear(true, true); this.createFamiliars(); if (this.makiraBeams) this.makiraBeams.clear(true, true); if (this.makiraAttackTimer) this.makiraAttackTimer.remove(); this.makiraAttackTimer = this.time.addEvent({ delay: MAKIRA_ATTACK_INTERVAL, callback: this.fireMakiraBeam, callbackScope: this, loop: true }); console.log(">>> Makira Familiars summoned."); } else { console.log(">>> Makira already active, restarting timer."); } const duration = POWERUP_DURATION[POWERUP_TYPES.MAKIRA]; if (this.powerUpTimers[POWERUP_TYPES.MAKIRA]) this.powerUpTimers[POWERUP_TYPES.MAKIRA].remove(); this.powerUpTimers[POWERUP_TYPES.MAKIRA] = this.time.delayedCall(duration, () => { console.log(`>>> Makira expired.`); this.deactivateMakira(); this.powerUpTimers[POWERUP_TYPES.MAKIRA] = null; }, [], this); console.log(`>>> Makira timer started (${duration}ms).`); }
    deactivateMakira() { if (this.isMakiraActive) { console.log(">>> Deactivating Makira."); this.isMakiraActive = false; if (this.makiraAttackTimer) { this.makiraAttackTimer.remove(); this.makiraAttackTimer = null; } if (this.powerUpTimers[POWERUP_TYPES.MAKIRA]) { this.powerUpTimers[POWERUP_TYPES.MAKIRA].remove(); this.powerUpTimers[POWERUP_TYPES.MAKIRA] = null; } if (this.familiars) { this.familiars.clear(true, true); } if (this.makiraBeams) { this.makiraBeams.clear(true, true); } } }
    createFamiliars() { if(!this.paddle)return;const px=this.paddle.x;const py=this.paddle.y-PADDLE_HEIGHT/2-MAKIRA_FAMILIAR_SIZE;const fL=this.familiars.create(px-MAKIRA_FAMILIAR_OFFSET,py,null).setDisplaySize(MAKIRA_FAMILIAR_SIZE*2,MAKIRA_FAMILIAR_SIZE*2).setTint(MAKIRA_FAMILIAR_COLOR);if(fL.body){fL.body.setAllowGravity(false).setImmovable(true);}const fR=this.familiars.create(px+MAKIRA_FAMILIAR_OFFSET,py,null).setDisplaySize(MAKIRA_FAMILIAR_SIZE*2,MAKIRA_FAMILIAR_SIZE*2).setTint(MAKIRA_FAMILIAR_COLOR);if(fR.body){fR.body.setAllowGravity(false).setImmovable(true);}console.log("Familiars created.");}
    fireMakiraBeam() { console.log(">>> fireMakiraBeam CALLED"); if (!this.isMakiraActive || !this.familiars || this.isStageClearing || this.isGameOver) { console.log(">>> fireMakiraBeam aborted"); return; } console.log(">>> Firing Makira beams attempt..."); this.familiars.getChildren().forEach(f => { if (f.active) { console.log(">>> Creating beam for familiar at:", f.x, f.y); const beam = this.makiraBeams.create(f.x, f.y - MAKIRA_FAMILIAR_SIZE, null).setDisplaySize(MAKIRA_BEAM_WIDTH, MAKIRA_BEAM_HEIGHT).setTint(MAKIRA_BEAM_COLOR); console.log(">>> Beam object created:", beam ? beam.active : 'null'); if (beam && beam.body) { console.log(">>> Setting beam velocity..."); beam.body.setVelocity(0, -MAKIRA_BEAM_SPEED); beam.body.setAllowGravity(false); console.log(`>>> Beam body check: enable=${beam.body.enable}, w=${beam.body.width}, h=${beam.body.height}`); console.log(">>> Beam velocity set."); } else { console.error("Beam body fail!"); if (beam) beam.destroy(); } } else { console.log(">>> Familiar inactive."); } }); console.log(">>> fireMakiraBeam finished loop."); }
    hitBrickWithMakiraBeam(beam, brick) { console.log(">>> hitBrickWithMakiraBeam ENTER"); if (!beam || !brick || !beam.active || !brick.active || this.isStageClearing || this.isGameOver) { console.log(">>> hitBrickWithMakiraBeam aborted"); return; } console.log(">>> Makira beam hit brick at:", brick.x, brick.y); const brickX = brick.x, brickY = brick.y; try { console.log(">>> Destroying beam..."); beam.destroy(); console.log(">>> Beam destroyed."); console.log(">>> Disabling brick body..."); brick.disableBody(true, true); console.log(">>> Brick body disabled."); console.log(">>> Updating score..."); this.score += 10; this.events.emit('updateScore', this.score); console.log(">>> Score updated."); console.log(">>> Increasing Vajra gauge..."); this.increaseVajraGauge(); console.log(">>> Vajra gauge increased."); console.log(">>> Checking for powerup drop (delayed)..."); if (Phaser.Math.FloatBetween(0, 1) < POWERUP_DROP_RATE) { this.time.delayedCall(1, () => { console.log(">>> Dropping powerup from Makira hit"); if(!this.isStageClearing && !this.isGameOver) this.dropPowerUp(brickX, brickY); }, [], this); } else { console.log(">>> No powerup drop."); } console.log(">>> Checking stage clear..."); if (!this.isStageClearing && this.bricks.countActive(true) === 0) { console.log(">>> Makira beam destroyed last brick!"); this.time.delayedCall(10, this.stageClear, [], this); } console.log(">>> Stage clear check finished."); } catch(error) { console.error("!!!!!!!!!! ERROR in hitBrickWithMakiraBeam !!!!!!!!!!", error); if (beam && beam.active) { beam.setActive(false).setVisible(false); if(beam.body) beam.body.enable = false; } } console.log(">>> hitBrickWithMakiraBeam END"); }
    activateMakora() { console.log(">>> Activating Makora!"); if(this.isMakiraActive) this.deactivateMakira(); this.deactivateVajra(); if (!this.isMakoraActive) { this.isMakoraActive = true; const originalWidth = this.paddle.getData('originalWidth'); if (!originalWidth) { console.error("Original width N/A!"); return;} this.createSecondPaddle(); if (this.paddle && this.paddle2?.active) { const gap = this.gameWidth * MAKORA_PADDLE_GAP_RATIO; const halfWidth = originalWidth / 2; const currentMidX = this.paddle.x + halfWidth; const minX = halfWidth + gap/2; const maxX = this.gameWidth - minX; const targetX = Phaser.Math.Clamp(currentMidX, minX, maxX); this.paddle.x = targetX - gap / 2 - halfWidth; this.paddle2.x = targetX + gap / 2 + halfWidth; if (this.paddle.body) this.paddle.body.setSize(originalWidth, PADDLE_HEIGHT); if (this.paddle2.body) this.paddle2.body.setSize(originalWidth, PADDLE_HEIGHT); console.log(`>>> Paddles pos: P1=${this.paddle.x.toFixed(0)}, P2=${this.paddle2.x.toFixed(0)} W=${originalWidth}`); } else { console.error(">>> Failed positioning paddles!"); } const duration = POWERUP_DURATION[POWERUP_TYPES.MAKORA]; if (this.powerUpTimers[POWERUP_TYPES.MAKORA]) this.powerUpTimers[POWERUP_TYPES.MAKORA].remove(); this.powerUpTimers[POWERUP_TYPES.MAKORA] = this.time.delayedCall(duration, () => { console.log(">>> Makora expired."); this.deactivateMakora(); this.powerUpTimers[POWERUP_TYPES.MAKORA] = null; }, [], this); console.log(`>>> Makora split started (${duration}ms).`); } else { console.log(">>> Makora already active, restarting timer."); const duration = POWERUP_DURATION[POWERUP_TYPES.MAKORA]; if (this.powerUpTimers[POWERUP_TYPES.MAKORA]) this.powerUpTimers[POWERUP_TYPES.MAKORA].remove(); this.powerUpTimers[POWERUP_TYPES.MAKORA] = this.time.delayedCall(duration, () => { console.log(">>> Makora expired."); this.deactivateMakora(); this.powerUpTimers[POWERUP_TYPES.MAKORA] = null; }, [], this); console.log(`>>> Makora timer restarted (${duration}ms).`); } this.setColliders(); }
    deactivateMakora() { if (this.isMakoraActive) { console.log(">>> Deactivating Makora."); this.isMakoraActive = false; if (this.powerUpTimers[POWERUP_TYPES.MAKORA]) { this.powerUpTimers[POWERUP_TYPES.MAKORA].remove(); this.powerUpTimers[POWERUP_TYPES.MAKORA] = null; } if (this.paddle2) { if (this.ballPaddle2Collider) this.ballPaddle2Collider.destroy(); this.paddle2.destroy(); this.paddle2 = null; this.ballPaddle2Collider = null; console.log(">>> Paddle 2 destroyed."); } this.setColliders(); } }
    createSecondPaddle() { if (!this.paddle) {console.error("Cannot create paddle2!"); return;} if (this.paddle2 && this.paddle2.active) { console.warn(">>> Paddle2 exists."); return; } const originalWidth = this.paddle.getData('originalWidth'); if (!originalWidth) { console.error("No originalWidth!"); return; } const gap = this.gameWidth * MAKORA_PADDLE_GAP_RATIO; const newPaddleX = this.paddle.x + (originalWidth / 2) + (gap / 2) + (originalWidth / 2); this.paddle2 = this.physics.add.image(newPaddleX, this.paddle.y, null).setDisplaySize(originalWidth, PADDLE_HEIGHT).setTint(0xcccccc).setImmovable(true); if (this.paddle2.body) { this.paddle2.body.setSize(originalWidth, PADDLE_HEIGHT); this.paddle2.body.setAllowGravity(false); } else { console.error("Failed paddle2 body!"); if(this.paddle2) this.paddle2.destroy();} console.log(">>> Paddle 2 created."); }

    // --- ゲームフロー ---
    loseLife() { if(this.isStageClearing||this.isGameOver||this.lives<=0)return; console.log("Losing life."); this.deactivateMakira(); this.deactivateMakora(); this.deactivateVajra(); this.lives--; this.events.emit('updateLives',this.lives); this.isBallLaunched=false; Object.keys(this.powerUpTimers).forEach(t=>{if(this.powerUpTimers[t]){this.powerUpTimers[t].remove();this.powerUpTimers[t]=null;if(t!==POWERUP_TYPES.MAKIRA&&t!==POWERUP_TYPES.MAKORA)this.deactivatePowerByType(t);}}); if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove(); this.sindaraAttractionTimer=null; if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove(); this.sindaraMergeTimer=null; const as=this.balls.getMatching('isSindara',true); if(as.length>0)this.deactivateSindara(as); if(this.lives>0)this.time.delayedCall(500,this.resetForNewLife,[],this); else this.time.delayedCall(500,this.gameOver,[],this); }
    resetForNewLife() { if(this.isGameOver||this.isStageClearing){console.log(`>>> reset aborted`);return;} console.log(">>> reset START"); if(this.balls){console.log(">>> Clearing balls...");this.balls.clear(true,true);} if(this.paddle){console.log(">>> Resetting paddle...");this.paddle.x=this.gameWidth/2;this.paddle.y=this.gameHeight-PADDLE_Y_OFFSET; if(!this.isMakoraActive){ const ow = this.paddle.getData('originalWidth'); if(ow) {this.paddle.setDisplaySize(ow, PADDLE_HEIGHT); if(this.paddle.body) this.paddle.body.setSize(ow, PADDLE_HEIGHT);} console.log(">>> Paddle width reset.");}} let nb=null; if(this.paddle){console.log(">>> Creating ball...");nb=this.createAndAddBall(this.paddle.x,this.paddle.y-PADDLE_HEIGHT/2-BALL_RADIUS);}else{console.error(">>> Paddle N/A!");nb=this.createAndAddBall(this.gameWidth/2,this.gameHeight-PADDLE_Y_OFFSET-PADDLE_HEIGHT/2-BALL_RADIUS);} if(!nb||!nb.active)console.error(">>> Ball create failed!");else console.log(">>> Ball created. Active:",nb.active); this.isBallLaunched=false; console.log(">>> Calling setColliders...");this.setColliders(); console.log(">>> reset END"); }
    gameOver() { if(this.isGameOver)return; this.isGameOver=true; console.log("Game Over!"); this.deactivateMakira(); this.deactivateMakora(); this.deactivateVajra(); if(this.gameOverText)this.gameOverText.setVisible(true); this.physics.pause(); if(this.balls){this.balls.getChildren().forEach(b=>{if(b.active){b.setVelocity(0,0);if(b.body)b.body.enable=false;}}); } Object.values(this.powerUpTimers).forEach(t=>{if(t)t.remove();}); this.powerUpTimers={}; if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove();this.sindaraAttractionTimer=null; if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove();this.sindaraMergeTimer=null; }
    stageClear() { if(this.isStageClearing||this.isGameOver){console.log(`>>> stageClear skipped.`);return;} this.isStageClearing=true; console.log(`>>> Stage ${this.currentStage} Clear!`); this.deactivateMakira(); this.deactivateMakora(); this.deactivateVajra(); try{this.physics.pause();console.log(">>> Physics paused."); Object.keys(this.powerUpTimers).forEach(t=>{if(this.powerUpTimers[t]){this.powerUpTimers[t].remove();this.powerUpTimers[t]=null;if(t!==POWERUP_TYPES.MAKIRA&&t!==POWERUP_TYPES.MAKORA)this.deactivatePowerByType(t);}}); if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove();this.sindaraAttractionTimer=null;if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove();this.sindaraMergeTimer=null;const as=this.balls.getMatching('isSindara',true);if(as.length>0)this.deactivateSindara(as);const abk=this.balls.getMatching('isBikara',true);if(abk.length>0)this.deactivateBikara(abk);const ai=this.balls.getMatching('isIndaraActive',true);ai.forEach(b=>this.deactivateIndaraForBall(b));const an=this.balls.getMatching('isAnilaActive',true);an.forEach(b=>this.deactivateAnilaForBall(b));console.log(">>> Powers deactivated.");if(this.balls){this.balls.getChildren().forEach(b=>{if(b.active){b.setVelocity(0,0).setVisible(false).setActive(false);if(b.body)b.body.enable=false;}});console.log(">>> Balls cleared.");}if(this.bricks){this.bricks.getChildren().forEach(br=>{if(br.getData('isMarkedByBikara'))br.setData('isMarkedByBikara',false);});console.log(">>> Marks cleared.");}if(this.powerUps){this.powerUps.clear(true,true);console.log(">>> Powerups cleared.");}console.log(`>>> Stage clear msg`);this.currentStage++;console.log(`>>> Stage inc:${this.currentStage}.`);const max=this.currentMode===GAME_MODE.ALL_STARS?10:12;console.log(`>>> Check max:${this.currentStage}>${max}`);if(this.currentStage>max){console.log(">>> Calling gameComplete...");this.gameComplete();}else{console.log(">>> Setting up next stage...");this.events.emit('updateStage',this.currentStage);this.time.delayedCall(500,()=>{console.log(">>> delayedCall START.");if(!this.scene||!this.scene.isActive()||this.isGameOver){console.warn(`>>> delayedCall aborted.`);return;}try{console.log(">>> createBricks...");this.createBricks();console.log(">>> Bricks created.");this.isStageClearing=false;console.log(`>>> isStageClearing=${this.isStageClearing}`);console.log(">>> resetForNewLife...");this.resetForNewLife();console.log(">>> reset done.");console.log(">>> physics.resume...");this.physics.resume();console.log(">>> Physics resumed.");}catch(e){console.error("!!! ERROR in delayedCall !!!",e);this.isStageClearing=false;console.error(">>> Set isStageClearing=false");}console.log(">>> delayedCall END.");},[],this);}}catch(e){console.error("!!! ERROR stageClear !!!",e);this.isStageClearing=false;console.error(">>> Set isStageClearing=false");}console.log(">>> stageClear END.");}
    gameComplete() { console.log("Game Complete!"); alert(`ゲームクリア！\nスコア: ${this.score}`); this.returnToTitle(); }
    returnToTitle() { console.log("Return to Title..."); if(this.physics.world&&!this.physics.world.running)this.physics.resume(); if(this.scene.isActive('UIScene')){this.scene.stop('UIScene');console.log("UIScene stopped.");} this.time.delayedCall(10,()=>{if(this.scene&&this.scene.isActive()){console.log("Starting Title...");this.scene.start('TitleScene');}else console.warn("GS inactive.");}); }
    shutdown() { console.log("GS shutdown."); this.isGameOver=false; this.isStageClearing=false; this.deactivateMakira(); this.deactivateMakora(); this.deactivateVajra(); Object.values(this.powerUpTimers).forEach(t=>{if(t)t.remove(false);}); this.powerUpTimers={}; if(this.sindaraAttractionTimer)this.sindaraAttractionTimer.remove(false); this.sindaraAttractionTimer=null; if(this.sindaraMergeTimer)this.sindaraMergeTimer.remove(false); this.sindaraMergeTimer=null; if(this.input)this.input.removeAllListeners(); if(this.time)this.time.removeAllEvents(); if(this.physics.world)this.physics.world.off('worldbounds',this.handleWorldBounds,this); this.events.removeAllListeners(); if(this.balls)this.balls.destroy(true);this.balls=null; if(this.bricks)this.bricks.destroy(true);this.bricks=null; if(this.powerUps)this.powerUps.destroy(true);this.powerUps=null; if(this.paddle)this.paddle.destroy();this.paddle=null; this.ballPaddleCollider=null; this.ballBrickCollider=null; this.ballBrickOverlap=null; this.ballBallCollider=null; if(this.familiars)this.familiars.destroy(true);this.familiars=null; if(this.makiraBeams)this.makiraBeams.destroy(true);this.makiraBeams=null; if(this.makoraBullets)this.makoraBullets.destroy(true); this.makoraBullets=null; if(this.paddle2)this.paddle2.destroy(); this.paddle2=null; this.ballPaddle2Collider=null; console.log("GS cleanup finished."); }
}

// --- UIScene ---
class UIScene extends Phaser.Scene { constructor() { super({ key: 'UIScene', active: false }); this.livesText=null; this.scoreText=null; this.stageText=null; this.vajraGaugeText = null; } create() { console.log("UIScene Create"); this.gameWidth=this.scale.width; const ts={fontSize:'24px',fill:'#fff'}; this.livesText=this.add.text(16,16,'ライフ:',ts); this.stageText=this.add.text(this.gameWidth/2,16,'ステージ:',ts).setOrigin(0.5,0); this.scoreText=this.add.text(this.gameWidth-16,16,'スコア:',ts).setOrigin(1,0); this.vajraGaugeText = this.add.text(16, this.scale.height - 30, '奥義: -/-', { fontSize: '20px', fill: '#fff' }).setVisible(false); try{const gs=this.scene.get('GameScene');if(gs&&gs.events){console.log("UIScene: GS found.");this.registerGameEventListeners(gs);}else{this.scene.get('GameScene').events.once('create',this.registerGameEventListeners,this);console.log("UIScene: Waiting GS create...");}}catch(e){console.error("UIScene: Error get GS.",e);} this.events.on('shutdown',()=>{console.log("UIScene Shutdown.");try{const gs=this.scene.get('GameScene');if(gs&&gs.events){gs.events.off('updateLives',this.updateLivesDisplay,this);gs.events.off('updateScore',this.updateScoreDisplay,this);gs.events.off('updateStage',this.updateStageDisplay,this);gs.events.off('create',this.registerGameEventListeners,this);gs.events.off('activateVajraUI',this.activateVajraUIDisplay,this);gs.events.off('updateVajraGauge',this.updateVajraGaugeDisplay,this); gs.events.off('deactivateVajraUI', this.deactivateVajraUIDisplay, this);}}catch(e){/*Ignore*/}}); console.log("UIScene Create End"); } registerGameEventListeners(gs) { console.log("UIScene: Registering listeners."); if(!gs||!gs.events){console.error("UIScene: Invalid GS.");return;} gs.events.off('updateLives',this.updateLivesDisplay,this);gs.events.off('updateScore',this.updateScoreDisplay,this);gs.events.off('updateStage',this.updateStageDisplay,this);gs.events.off('activateVajraUI',this.activateVajraUIDisplay,this);gs.events.off('updateVajraGauge',this.updateVajraGaugeDisplay,this); gs.events.off('deactivateVajraUI', this.deactivateVajraUIDisplay, this); gs.events.on('updateLives',this.updateLivesDisplay,this);gs.events.on('updateScore',this.updateScoreDisplay,this);gs.events.on('updateStage',this.updateStageDisplay,this);gs.events.on('activateVajraUI',this.activateVajraUIDisplay,this);gs.events.on('updateVajraGauge',this.updateVajraGaugeDisplay,this); gs.events.on('deactivateVajraUI', this.deactivateVajraUIDisplay, this); try{if(gs.hasOwnProperty('lives'))this.updateLivesDisplay(gs.lives);if(gs.hasOwnProperty('score'))this.updateScoreDisplay(gs.score);if(gs.hasOwnProperty('currentStage'))this.updateStageDisplay(gs.currentStage); console.log("UIScene: Initial state updated.");}catch(e){console.error("UIScene: Error initial update.",e);} } updateLivesDisplay(l){if(this.livesText)this.livesText.setText(`ライフ: ${l}`);} updateScoreDisplay(s){if(this.scoreText)this.scoreText.setText(`スコア: ${s}`);} updateStageDisplay(st){if(this.stageText)this.stageText.setText(`ステージ: ${st}`);} activateVajraUIDisplay(iv,mv){console.log(`UIScene: Activate Vajra UI (${iv}/${mv})`);if(this.vajraGaugeText){this.vajraGaugeText.setText(`奥義: ${iv}/${mv}`).setVisible(true);}} updateVajraGaugeDisplay(cv){console.log(`UIScene: Update Vajra Gauge (${cv}/${VAJRA_GAUGE_MAX})`);if(this.vajraGaugeText&&this.vajraGaugeText.visible){this.vajraGaugeText.setText(`奥義: ${cv}/${VAJRA_GAUGE_MAX}`);}} deactivateVajraUIDisplay(){console.log("UIScene: Deactivate Vajra UI"); if(this.vajraGaugeText){this.vajraGaugeText.setVisible(false);}} }

// --- Phaserゲーム設定 ---
const config = { type: Phaser.AUTO, scale: { mode: Phaser.Scale.FIT, parent: 'phaser-game-container', autoCenter: Phaser.Scale.CENTER_BOTH, width: '100%', height: '100%' }, physics: { default: 'arcade', arcade: { debug: false, gravity: { y: 0 } } }, scene: [BootScene, TitleScene, GameScene, UIScene], input: { activePointers: 3, }, render: { pixelArt: false, antialias: true, } };

// --- ゲーム開始 ---
window.onload = () => { const game = new Phaser.Game(config); console.log("Phaser Game instance created."); };